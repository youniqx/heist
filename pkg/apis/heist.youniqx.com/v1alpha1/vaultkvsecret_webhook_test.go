/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var _ = Describe("VaultKVSecret Webhooks", func() {
	Context("Creating VaultKVSecrets", func() {
		When("Creating a VaultKVSecret with a static field", func() {
			var secret *VaultKVSecret

			BeforeEach(func() {
				secret = &VaultKVSecret{
					TypeMeta: metav1.TypeMeta{
						Kind:       "VaultKVSecret",
						APIVersion: "heist.youniqx.com/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Name:      "some-secret",
						Namespace: "default",
					},
					Spec: VaultKVSecretSpec{
						Engine: "some-engine",
						Path:   "",
						Fields: map[string]*VaultKVSecretField{
							"some-field": {
								CipherText: EncryptedValue(defaultCipherText),
							},
						},
						DeleteProtection: false,
					},
					Status: VaultKVSecretStatus{},
				}
			})

			AfterEach(func() {
				Expect(K8sClient.Delete(ctx, secret)).To(Succeed())
			})

			It("Should be able to create the secret", func() {
				Expect(K8sClient.Create(ctx, secret)).To(Succeed())
			})
		})

		When("Creating a VaultKVSecret with an auto generated field", func() {
			var secret *VaultKVSecret

			BeforeEach(func() {
				secret = &VaultKVSecret{
					TypeMeta: metav1.TypeMeta{
						Kind:       "VaultKVSecret",
						APIVersion: "heist.youniqx.com/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Name:      "some-secret",
						Namespace: "default",
					},
					Spec: VaultKVSecretSpec{
						Engine: "some-engine",
						Path:   "",
						Fields: map[string]*VaultKVSecretField{
							"some-field": {
								AutoGenerated: true,
							},
						},
						DeleteProtection: false,
					},
					Status: VaultKVSecretStatus{},
				}
			})

			AfterEach(func() {
				Expect(K8sClient.Delete(ctx, secret)).To(Succeed())
			})

			It("Should be able to create the secret", func() {
				Expect(K8sClient.Create(ctx, secret)).To(Succeed())
			})
		})

		When("Creating a VaultKVSecret with a field without a cipher text or AutoGenerated flag", func() {
			var secret *VaultKVSecret

			BeforeEach(func() {
				secret = &VaultKVSecret{
					TypeMeta: metav1.TypeMeta{
						Kind:       "VaultKVSecret",
						APIVersion: "heist.youniqx.com/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Name:      "some-secret",
						Namespace: "default",
					},
					Spec: VaultKVSecretSpec{
						Engine: "some-engine",
						Path:   "",
						Fields: map[string]*VaultKVSecretField{
							"some-field": {},
						},
						DeleteProtection: false,
					},
					Status: VaultKVSecretStatus{},
				}
			})

			AfterEach(func() {
				Expect(K8sClient.Delete(ctx, secret)).NotTo(Succeed())
			})

			It("Should throw an error", func() {
				Expect(K8sClient.Create(ctx, secret)).NotTo(Succeed())
			})
		})

		When("Creating a VaultKVSecret with invalid cipher text", func() {
			var secret *VaultKVSecret

			BeforeEach(func() {
				secret = &VaultKVSecret{
					TypeMeta: metav1.TypeMeta{
						Kind:       "VaultKVSecret",
						APIVersion: "heist.youniqx.com/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Name:      "some-secret",
						Namespace: "default",
					},
					Spec: VaultKVSecretSpec{
						Engine: "some-engine",
						Path:   "",
						Fields: map[string]*VaultKVSecretField{
							"some-field": {
								CipherText: "some-text",
							},
						},
						DeleteProtection: false,
					},
					Status: VaultKVSecretStatus{},
				}
			})

			AfterEach(func() {
				Expect(K8sClient.Delete(ctx, secret)).NotTo(Succeed())
			})

			It("Should throw an error", func() {
				Expect(K8sClient.Create(ctx, secret)).NotTo(Succeed())
			})
		})

		When("Creating a VaultKVSecret with a path ending in a slash", func() {
			var secret *VaultKVSecret

			BeforeEach(func() {
				secret = &VaultKVSecret{
					TypeMeta: metav1.TypeMeta{
						Kind:       "VaultKVSecret",
						APIVersion: "heist.youniqx.com/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Name:      "some-secret",
						Namespace: "default",
					},
					Spec: VaultKVSecretSpec{
						Engine: "some-engine",
						Path:   "some/path/",
						Fields: map[string]*VaultKVSecretField{
							"some-field": {
								CipherText: EncryptedValue(defaultCipherText),
							},
						},
						DeleteProtection: false,
					},
					Status: VaultKVSecretStatus{},
				}
			})

			AfterEach(func() {
				Expect(K8sClient.Delete(ctx, secret)).NotTo(Succeed())
			})

			It("Should throw an error", func() {
				Expect(K8sClient.Create(ctx, secret)).NotTo(Succeed())
			})
		})

		When("Creating a VaultKVSecret with a path starting with a slash", func() {
			var secret *VaultKVSecret

			BeforeEach(func() {
				secret = &VaultKVSecret{
					TypeMeta: metav1.TypeMeta{
						Kind:       "VaultKVSecret",
						APIVersion: "heist.youniqx.com/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Name:      "some-secret",
						Namespace: "default",
					},
					Spec: VaultKVSecretSpec{
						Engine: "some-engine",
						Path:   "/some/path",
						Fields: map[string]*VaultKVSecretField{
							"some-field": {
								CipherText: EncryptedValue(defaultCipherText),
							},
						},
						DeleteProtection: false,
					},
					Status: VaultKVSecretStatus{},
				}
			})

			AfterEach(func() {
				Expect(K8sClient.Delete(ctx, secret)).NotTo(Succeed())
			})

			It("Should throw an error", func() {
				Expect(K8sClient.Create(ctx, secret)).NotTo(Succeed())
			})
		})

		When("Creating a VaultKVSecret without an engine", func() {
			var secret *VaultKVSecret

			BeforeEach(func() {
				secret = &VaultKVSecret{
					TypeMeta: metav1.TypeMeta{
						Kind:       "VaultKVSecret",
						APIVersion: "heist.youniqx.com/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Name:      "some-secret",
						Namespace: "default",
					},
					Spec: VaultKVSecretSpec{
						Engine: "",
						Path:   "",
						Fields: map[string]*VaultKVSecretField{
							"some-field": {
								CipherText: EncryptedValue(defaultCipherText),
							},
						},
						DeleteProtection: false,
					},
					Status: VaultKVSecretStatus{},
				}
			})

			AfterEach(func() {
				Expect(K8sClient.Delete(ctx, secret)).NotTo(Succeed())
			})

			It("Should throw an error", func() {
				Expect(K8sClient.Create(ctx, secret)).NotTo(Succeed())
			})
		})

		When("Creating a VaultKVSecret without any fields", func() {
			var secret *VaultKVSecret

			BeforeEach(func() {
				secret = &VaultKVSecret{
					TypeMeta: metav1.TypeMeta{
						Kind:       "VaultKVSecret",
						APIVersion: "heist.youniqx.com/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Name:      "some-secret",
						Namespace: "default",
					},
					Spec: VaultKVSecretSpec{
						Engine:           "some-engine",
						Path:             "",
						Fields:           map[string]*VaultKVSecretField{},
						DeleteProtection: false,
					},
					Status: VaultKVSecretStatus{},
				}
			})

			AfterEach(func() {
				Expect(K8sClient.Delete(ctx, secret)).NotTo(Succeed())
			})

			It("Should throw an error", func() {
				Expect(K8sClient.Create(ctx, secret)).NotTo(Succeed())
			})
		})
	})

	Context("Deleting VaultKVSecrets", func() {
		When("Deleting a VaultKVSecret with DeleteProtection enabled", func() {
			var secret *VaultKVSecret

			BeforeEach(func() {
				secret = &VaultKVSecret{
					TypeMeta: metav1.TypeMeta{
						Kind:       "VaultKVSecret",
						APIVersion: "heist.youniqx.com/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Name:      "some-secret",
						Namespace: "default",
					},
					Spec: VaultKVSecretSpec{
						Engine: "some-engine",
						Path:   "",
						Fields: map[string]*VaultKVSecretField{
							"some-field": {
								CipherText: EncryptedValue(defaultCipherText),
							},
						},
						DeleteProtection: true,
					},
					Status: VaultKVSecretStatus{},
				}
				Expect(K8sClient.Create(ctx, secret)).To(Succeed())
			})

			AfterEach(func() {
				secret.Spec.DeleteProtection = false
				Expect(K8sClient.Update(ctx, secret)).To(Succeed())
				Expect(K8sClient.Delete(ctx, secret)).To(Succeed())
			})

			It("Should throw an error", func() {
				Expect(K8sClient.Delete(ctx, secret)).NotTo(Succeed())
			})
		})

		When("Deleting a VaultKVSecret with DeleteProtection disabled", func() {
			var secret *VaultKVSecret

			BeforeEach(func() {
				secret = &VaultKVSecret{
					TypeMeta: metav1.TypeMeta{
						Kind:       "VaultKVSecret",
						APIVersion: "heist.youniqx.com/v1alpha1",
					},
					ObjectMeta: metav1.ObjectMeta{
						Name:      "some-secret",
						Namespace: "default",
					},
					Spec: VaultKVSecretSpec{
						Engine: "some-engine",
						Path:   "",
						Fields: map[string]*VaultKVSecretField{
							"some-field": {
								CipherText: EncryptedValue(defaultCipherText),
							},
						},
						DeleteProtection: false,
					},
					Status: VaultKVSecretStatus{},
				}
				Expect(K8sClient.Create(ctx, secret)).To(Succeed())
			})

			AfterEach(func() {
				Expect(K8sClient.Delete(ctx, secret)).NotTo(Succeed())
			})

			It("Should be able to delete the secret", func() {
				Expect(K8sClient.Delete(ctx, secret)).To(Succeed())
			})
		})
	})
})
