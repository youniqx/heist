package vaultkvsecret

import (
	"fmt"
	"path/filepath"

	heistv1alpha1 "github.com/youniqx/heist/pkg/apis/heist.youniqx.com/v1alpha1"
	"github.com/youniqx/heist/pkg/controllers/common"
	"github.com/youniqx/heist/pkg/erx"
	"github.com/youniqx/heist/pkg/managed"
	"github.com/youniqx/heist/pkg/vault/core"
	"github.com/youniqx/heist/pkg/vault/kvsecret"
	"github.com/youniqx/heist/pkg/vault/policy"
)

var ErrDecryptFailed = erx.New("VaultKVSecret", "decrypt failed")

type deployedSecret struct {
	Provisioned     bool
	Secret          *kvsecret.KvSecret
	EncryptedFields map[string]string
	Engine          core.MountPath
	Policy          *policy.Policy
}

func (r *Reconciler) determineState(engine *heistv1alpha1.VaultKVSecretEngine, secret *heistv1alpha1.VaultKVSecret) (desired *deployedSecret, current *deployedSecret, err error) {
	desired, err = r.determineDesiredState(engine, secret)
	if err != nil {
		return nil, nil, err
	}

	current, err = r.determineCurrentState(secret)
	if err != nil {
		return nil, nil, err
	}

	return desired, current, nil
}

func (r *Reconciler) determineCurrentState(secret *heistv1alpha1.VaultKVSecret) (*deployedSecret, error) {
	plainTextFields := make(map[string]string)
	encryptedFields := make(map[string]string)
	for name, cipherText := range secret.Status.Fields {
		plainTextBytes, err := r.VaultAPI.TransitDecrypt(managed.TransitEngine, managed.TransitKey, cipherText)
		if err != nil {
			return nil, err
		}
		plainTextFields[name] = string(plainTextBytes)
		encryptedFields[name] = cipherText
	}

	result := &deployedSecret{
		Provisioned: secret.Status.Engine != "",
		Secret: &kvsecret.KvSecret{
			Path:   secret.Status.Path,
			Fields: plainTextFields,
		},
		EncryptedFields: encryptedFields,
		Engine:          core.MountPath(secret.Status.Engine),
		Policy: &policy.Policy{
			Name: fmt.Sprintf("managed.kv.%s.%s", secret.Namespace, secret.Name),
			Rules: []*policy.Rule{
				{
					Path: filepath.Join(secret.Status.Engine, "data", secret.Status.Path),
					Capabilities: []policy.Capability{
						policy.ReadCapability,
					},
				},
			},
		},
	}

	return result, nil
}

func (r *Reconciler) determineDesiredState(engine *heistv1alpha1.VaultKVSecretEngine, secret *heistv1alpha1.VaultKVSecret) (*deployedSecret, error) {
	plainTextFields := make(map[string]string)
	encryptedFields := make(map[string]string)
	for name, field := range secret.Spec.Fields {
		if err := r.determineDesiredStateForField(plainTextFields, encryptedFields, name, field, secret); err != nil {
			return nil, err
		}
	}

	mountPath, err := engine.GetMountPath()
	if err != nil {
		return nil, err
	}

	secretPath, err := secret.GetSecretPath()
	if err != nil {
		return nil, err
	}

	result := &deployedSecret{
		Secret: &kvsecret.KvSecret{
			Path:   secretPath,
			Fields: plainTextFields,
		},
		EncryptedFields: encryptedFields,
		Engine:          core.MountPath(mountPath),
		Policy: &policy.Policy{
			Name: common.GetPolicyNameForSecret(secret),
			Rules: []*policy.Rule{
				{
					Path: filepath.Join(mountPath, "data", secretPath),
					Capabilities: []policy.Capability{
						policy.ReadCapability,
					},
				},
			},
		},
	}

	return result, nil
}

func (r *Reconciler) determineDesiredStateForField(plainTextFields map[string]string, encryptedFields map[string]string, name string, field *heistv1alpha1.VaultKVSecretField, secret *heistv1alpha1.VaultKVSecret) error {
	switch {
	case field.CipherText != "":
		plainTextBytes, err := r.VaultAPI.TransitDecrypt(managed.TransitEngine, managed.TransitKey, string(field.CipherText))
		if err != nil {
			return ErrDecryptFailed.WithDetails(fmt.Sprintf("failed to decrypt cipher text in field %s", name)).WithCause(err)
		}
		plainTextFields[name] = string(plainTextBytes)
		encryptedFields[name] = string(field.CipherText)
	case field.AutoGenerated:
		existingCipherText := secret.Status.Fields[name]

		var desiredLength int
		if field.AutoGeneratedLength <= 0 {
			desiredLength = 64
		} else {
			desiredLength = field.AutoGeneratedLength
		}

		if existingCipherText != "" {
			plainTextBytes, err := r.VaultAPI.TransitDecrypt(managed.TransitEngine, managed.TransitKey, existingCipherText)
			if err != nil {
				return err
			}
			plainText := string(plainTextBytes)
			if len(plainText) == desiredLength {
				plainTextFields[name] = plainText
				encryptedFields[name] = existingCipherText
				return nil
			}
		}

		plainText, err := r.VaultAPI.GenerateRandomString(desiredLength)
		if err != nil {
			return err
		}
		cipherText, err := r.VaultAPI.TransitEncrypt(managed.TransitEngine, managed.TransitKey, []byte(plainText))
		if err != nil {
			return err
		}
		plainTextFields[name] = plainText
		encryptedFields[name] = cipherText
	default:
		return fmt.Errorf("field %s is in an unreconcilable state", name)
	}

	return nil
}
