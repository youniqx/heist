/*
Copyright 2021.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package vaultkvsecret

import (
	"context"
	"fmt"
	"path/filepath"
	"time"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	heistv1alpha1 "github.com/youniqx/heist/pkg/apis/heist.youniqx.com/v1alpha1"
	. "github.com/youniqx/heist/pkg/testhelper"
	"github.com/youniqx/heist/pkg/vault/core"
	. "github.com/youniqx/heist/pkg/vault/matchers"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

var _ = Describe("VaultKVSecret Controller", func() {
	When("Creating a VaultKVSecret whose engine does not exist", func() {
		var engine *heistv1alpha1.VaultKVSecretEngine
		var secret *heistv1alpha1.VaultKVSecret

		BeforeEach(func() {
			engine = &heistv1alpha1.VaultKVSecretEngine{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecretEngine",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "default-engine",
					Namespace: "default",
				},
				Spec:   heistv1alpha1.VaultKVSecretEngineSpec{},
				Status: heistv1alpha1.VaultKVSecretEngineStatus{},
			}

			secret = &heistv1alpha1.VaultKVSecret{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecret",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "secret",
					Namespace: "default",
				},
				Spec: heistv1alpha1.VaultKVSecretSpec{
					Engine: engine.Name,
					Fields: map[string]*heistv1alpha1.VaultKVSecretField{
						"some-field": {
							CipherText: heistv1alpha1.EncryptedValue(Test.DefaultCipherText),
						},
					},
					DeleteProtection: false,
				},
				Status: heistv1alpha1.VaultKVSecretStatus{},
			}
		})

		AfterEach(func() {
			afterEachCleanup(engine, secret)
		})

		It("Should go into the Waiting state", func() {
			Test.K8sEnv.Create(secret)
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionFalse,
				heistv1alpha1.Conditions.Reasons.ErrorConfig,
				"Referenced engine not found",
			))
		})

		It("Should be provisioned once the engine is created", func() {
			Test.K8sEnv.Create(secret)
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionFalse,
				heistv1alpha1.Conditions.Reasons.ErrorConfig,
				"Referenced engine not found",
			))
			Test.VaultEnv.KvEngine(engine).Should(BeNil())
			Test.VaultEnv.KvSecret(engine, secret).Should(BeNil())

			Test.K8sEnv.Create(engine)
			Test.K8sEnv.Object(engine).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Engine has been provisioned",
			))
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))
			Test.VaultEnv.KvEngine(engine).ShouldNot(BeNil())
			Test.VaultEnv.KvSecret(engine, secret).Should(HavePath(secret.Name))
			Test.VaultEnv.KvSecret(engine, secret).Should(HaveKvSecretFields(map[string]string{
				"some-field": "ASDF ASDF",
			}))
		})
	})

	When("Creating an auto generated VaultKVSecret whose engine does exist", func() {
		var engine *heistv1alpha1.VaultKVSecretEngine
		var secret *heistv1alpha1.VaultKVSecret

		BeforeEach(func() {
			engine = &heistv1alpha1.VaultKVSecretEngine{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecretEngine",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "another-engine",
					Namespace: "default",
				},
				Spec:   heistv1alpha1.VaultKVSecretEngineSpec{},
				Status: heistv1alpha1.VaultKVSecretEngineStatus{},
			}

			secret = &heistv1alpha1.VaultKVSecret{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecret",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "some-secret",
					Namespace: "default",
				},
				Spec: heistv1alpha1.VaultKVSecretSpec{
					Engine: engine.Name,
					Fields: map[string]*heistv1alpha1.VaultKVSecretField{
						"some-field": {
							AutoGenerated: true,
						},
					},
					DeleteProtection: false,
				},
				Status: heistv1alpha1.VaultKVSecretStatus{},
			}

			Test.K8sEnv.Create(engine)
			Test.VaultEnv.KvEngine(engine).Should(HavePath("managed/kv/default/another-engine"))
			Test.K8sEnv.Object(engine).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Engine has been provisioned",
			))
		})

		AfterEach(func() {
			afterEachCleanup(engine, secret)
		})

		It("Should auto generate a string with length 64 if nothing is configured", func() {
			Test.K8sEnv.Create(secret)
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))
			Test.VaultEnv.KvSecret(engine, secret).Should(HavePath(secret.Name))
			Test.VaultEnv.KvSecret(engine, secret).Should(HaveKvSecretFieldFieldWithLength("some-field", 64))
		})

		It("Should auto generate a string with length 32 if AutoGeneratedLength is set to 32", func() {
			secret.Spec.Fields["some-field"].AutoGeneratedLength = 32
			Test.K8sEnv.Create(secret)
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))
			Test.VaultEnv.KvSecret(engine, secret).Should(HavePath(secret.Name))
			Test.VaultEnv.KvSecret(engine, secret).Should(HaveKvSecretFieldFieldWithLength("some-field", 32))
		})
	})

	When("Deleting an engine containing VaultKVSecrets", func() {
		var engine *heistv1alpha1.VaultKVSecretEngine
		var secret *heistv1alpha1.VaultKVSecret

		BeforeEach(func() {
			engine = &heistv1alpha1.VaultKVSecretEngine{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecretEngine",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "yet-another-engine",
					Namespace: "default",
				},
				Spec:   heistv1alpha1.VaultKVSecretEngineSpec{},
				Status: heistv1alpha1.VaultKVSecretEngineStatus{},
			}

			secret = &heistv1alpha1.VaultKVSecret{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecret",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "some-secret",
					Namespace: "default",
				},
				Spec: heistv1alpha1.VaultKVSecretSpec{
					Engine: engine.Name,
					Fields: map[string]*heistv1alpha1.VaultKVSecretField{
						"some-field": {
							CipherText: heistv1alpha1.EncryptedValue(Test.DefaultCipherText),
						},
					},
					DeleteProtection: false,
				},
				Status: heistv1alpha1.VaultKVSecretStatus{},
			}

			Test.K8sEnv.Create(engine)
			Test.K8sEnv.Create(secret)
			Test.K8sEnv.Object(engine).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Engine has been provisioned",
			))
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))
			Test.VaultEnv.KvSecret(engine, secret).Should(HavePath(secret.Name))
			Test.VaultEnv.KvSecret(engine, secret).Should(HaveKvSecretFields(map[string]string{
				"some-field": "ASDF ASDF",
			}))
		})

		AfterEach(func() {
			afterEachCleanup(engine, secret)
		})

		It("Should force the secret into the ErrorConfig state again", func() {
			for i := 0; i < 3; i++ {
				fmt.Printf(":::: test debug output :::: trying to delete secret engine (try %d/3)\n", i+1)
				err := Test.K8sClient.Delete(context.TODO(), engine)
				if err != nil {
					fmt.Printf(":::: test debug output :::: couldn't delete engine %s (%d/3) in test case 'Should force the secret into the ErrorConfig state again': %v\n", engine.GetName(), i+1, err)
				}

				vault, _ := Test.VaultEnv.GetAPI()
				vaultEngineExists, err := vault.HasEngine(engine)
				if err != nil {
					fmt.Printf(":::: test debug output :::: couldn't check if vault still has engine: %v\n", err)
				}

				fmt.Printf(":::: test debug output :::: vault engine still exists?: %t\n", vaultEngineExists)
			}

			Test.VaultEnv.KvEngine(engine).Should(BeNil())
			Test.VaultEnv.KvSecret(engine, secret).Should(BeNil())
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionFalse,
				heistv1alpha1.Conditions.Reasons.ErrorConfig,
				"Referenced engine not found",
			))
		})
	})

	When("Moving a static secret from one engine to another", func() {
		var engineA *heistv1alpha1.VaultKVSecretEngine
		var engineB *heistv1alpha1.VaultKVSecretEngine
		var secret *heistv1alpha1.VaultKVSecret

		BeforeEach(func() {
			engineA = &heistv1alpha1.VaultKVSecretEngine{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecretEngine",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "first-engine",
					Namespace: "default",
				},
				Spec:   heistv1alpha1.VaultKVSecretEngineSpec{},
				Status: heistv1alpha1.VaultKVSecretEngineStatus{},
			}
			engineB = &heistv1alpha1.VaultKVSecretEngine{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecretEngine",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "second-engine",
					Namespace: "default",
				},
				Spec:   heistv1alpha1.VaultKVSecretEngineSpec{},
				Status: heistv1alpha1.VaultKVSecretEngineStatus{},
			}

			secret = &heistv1alpha1.VaultKVSecret{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecret",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "some-secret",
					Namespace: "default",
				},
				Spec: heistv1alpha1.VaultKVSecretSpec{
					Engine: engineA.Name,
					Fields: map[string]*heistv1alpha1.VaultKVSecretField{
						"some-field": {
							CipherText: heistv1alpha1.EncryptedValue(Test.DefaultCipherText),
						},
					},
					DeleteProtection: false,
				},
				Status: heistv1alpha1.VaultKVSecretStatus{},
			}

			Test.K8sEnv.Create(engineA)
			Test.K8sEnv.Create(engineB)
			Test.K8sEnv.Create(secret)
			Test.K8sEnv.Object(engineA).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Engine has been provisioned",
			))
			Test.K8sEnv.Object(engineB).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Engine has been provisioned",
			))
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))
			Test.VaultEnv.KvSecret(engineA, secret).Should(HavePath(secret.Name))
			Test.VaultEnv.KvSecret(engineA, secret).Should(HaveKvSecretFields(map[string]string{
				"some-field": "ASDF ASDF",
			}))
			Test.VaultEnv.KvSecret(engineB, secret).Should(BeNil())
		})

		AfterEach(func() {
			Test.K8sEnv.DeleteIfPresent(engineA, engineB, secret)
			Test.VaultEnv.KvSecret(engineA, secret).Should(BeNil())
			Test.VaultEnv.KvSecret(engineB, secret).Should(BeNil())
			Test.VaultEnv.KvEngine(engineA).Should(BeNil())
			Test.VaultEnv.KvEngine(engineB).Should(BeNil())
		})

		It("Should delete the secret in the previous engine and create it in the new engine", func() {
			// More complex logic needed to correctly update secret spec without
			// running into race condition with controller. The reason for this
			// is that the controller is still in the process of updating the
			// fields in the secret, while we are already fetching it and
			// setting the new engine.
			//
			// This leads to the apiserver rejecting our updates due to being
			// done on an outdated object.
			updateKvEnginePath := func() (err error) {
				err = Test.K8sClient.Get(context.TODO(), client.ObjectKeyFromObject(secret), secret)
				if err != nil {
					return fmt.Errorf("couldn't fetch current secret from apiserver: %w", err)
				}

				secret.Spec.Engine = engineB.Name

				err = Test.K8sClient.Update(context.TODO(), secret)
				if err != nil {
					return fmt.Errorf("couldn't update secret in apiserver: %w", err)
				}

				return nil
			}
			Eventually(updateKvEnginePath, 5*time.Second, 1*time.Second).Should(Succeed())

			Test.VaultEnv.KvSecret(engineB, secret).Should(HavePath(secret.Name))
			Test.VaultEnv.KvSecret(engineB, secret).Should(HaveKvSecretFields(map[string]string{
				"some-field": "ASDF ASDF",
			}))
			Test.VaultEnv.KvSecret(engineA, secret).Should(BeNil())
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))
		})
	})

	When("Changing the path of a static secret", func() {
		var engine *heistv1alpha1.VaultKVSecretEngine
		var secret *heistv1alpha1.VaultKVSecret

		BeforeEach(func() {
			engine = &heistv1alpha1.VaultKVSecretEngine{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecretEngine",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "first-engine",
					Namespace: "default",
				},
				Spec:   heistv1alpha1.VaultKVSecretEngineSpec{},
				Status: heistv1alpha1.VaultKVSecretEngineStatus{},
			}

			secret = &heistv1alpha1.VaultKVSecret{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecret",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "some-secret",
					Namespace: "default",
				},
				Spec: heistv1alpha1.VaultKVSecretSpec{
					Engine: engine.Name,
					Fields: map[string]*heistv1alpha1.VaultKVSecretField{
						"some-field": {
							CipherText: heistv1alpha1.EncryptedValue(Test.DefaultCipherText),
						},
					},
					DeleteProtection: false,
				},
				Status: heistv1alpha1.VaultKVSecretStatus{},
			}

			Test.K8sEnv.Create(engine)
			Test.K8sEnv.Create(secret)
			Test.K8sEnv.Object(engine).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Engine has been provisioned",
			))
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))
			Test.VaultEnv.KvSecret(engine, secret).Should(HavePath(secret.Name))
			Test.VaultEnv.KvSecret(engine, secret).Should(HaveKvSecretFields(map[string]string{
				"some-field": "ASDF ASDF",
			}))
		})

		AfterEach(func() {
			afterEachCleanup(engine, secret)
		})

		It("Should delete the secret in the previous location and create it in the new one", func() {
			// More complex logic needed to correctly update secret spec without
			// running into race condition with controller. The reason for this
			// is that the controller is still in the process of updating the
			// fields in the secret, while we are already fetching it and
			// setting the path.
			//
			// This leads to the apiserver rejecting our updates due to being
			// done on an outdated object.
			updateKvSecretPath := func() (err error) {
				err = Test.K8sClient.Get(context.TODO(), client.ObjectKeyFromObject(secret), secret)
				if err != nil {
					return fmt.Errorf("couldn't fetch current secret from apiserver: %w", err)
				}

				secret.Spec.Path = "some/other/path"

				err = Test.K8sClient.Update(context.TODO(), secret)
				if err != nil {
					return fmt.Errorf("couldn't update secret in apiserver: %w", err)
				}

				return nil
			}
			Eventually(updateKvSecretPath, 5*time.Second, 1*time.Second).Should(Succeed())

			Test.VaultEnv.KvSecret(engine, secret).Should(HavePath(filepath.Join("some/other/path", secret.Name)))
			Test.VaultEnv.KvSecret(engine, secret).Should(HaveKvSecretFields(map[string]string{
				"some-field": "ASDF ASDF",
			}))
			Test.VaultEnv.KvSecret(engine, core.SecretPath(secret.Name)).Should(BeNil())
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))
		})
	})

	When("Moving an auto generated secret from one engine to another", func() {
		var engineA *heistv1alpha1.VaultKVSecretEngine
		var engineB *heistv1alpha1.VaultKVSecretEngine
		var secret *heistv1alpha1.VaultKVSecret

		BeforeEach(func() {
			engineA = &heistv1alpha1.VaultKVSecretEngine{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecretEngine",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "first-engine",
					Namespace: "default",
				},
				Spec:   heistv1alpha1.VaultKVSecretEngineSpec{},
				Status: heistv1alpha1.VaultKVSecretEngineStatus{},
			}
			engineB = &heistv1alpha1.VaultKVSecretEngine{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecretEngine",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "second-engine",
					Namespace: "default",
				},
				Spec:   heistv1alpha1.VaultKVSecretEngineSpec{},
				Status: heistv1alpha1.VaultKVSecretEngineStatus{},
			}

			secret = &heistv1alpha1.VaultKVSecret{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecret",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "some-secret",
					Namespace: "default",
				},
				Spec: heistv1alpha1.VaultKVSecretSpec{
					Engine: engineA.Name,
					Fields: map[string]*heistv1alpha1.VaultKVSecretField{
						"some-field": {
							AutoGenerated: true,
						},
					},
					DeleteProtection: false,
				},
				Status: heistv1alpha1.VaultKVSecretStatus{},
			}

			Test.K8sEnv.Create(engineA)
			Test.K8sEnv.Create(engineB)
			Test.K8sEnv.Create(secret)
			Test.K8sEnv.Object(engineA).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Engine has been provisioned",
			))
			Test.K8sEnv.Object(engineB).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Engine has been provisioned",
			))
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))
			Test.VaultEnv.KvSecret(engineA, secret).Should(HavePath(secret.Name))
			Test.VaultEnv.KvSecret(engineA, secret).Should(HaveKvSecretFieldFieldWithLength("some-field", 64))
			Test.VaultEnv.KvSecret(engineA, secret).Should(BeStableFor(4.0 * time.Second))
			Test.VaultEnv.KvSecret(engineB, secret).Should(BeNil())
		})

		AfterEach(func() {
			Test.K8sEnv.DeleteIfPresent(engineA, engineB, secret)
			Test.VaultEnv.KvSecret(engineA, secret).Should(BeNil())
			Test.VaultEnv.KvSecret(engineB, secret).Should(BeNil())
			Test.VaultEnv.KvEngine(engineA).Should(BeNil())
			Test.VaultEnv.KvEngine(engineB).Should(BeNil())
		})

		It("Should delete the secret in the previous engine and create it in the new engine but keep the same values", func() {
			oldSecret, err := Test.RootAPI.ReadKvSecret(engineA, secret)
			Expect(err).NotTo(HaveOccurred())
			Expect(oldSecret.Fields["some-field"]).To(HaveLen(64))

			Expect(Test.K8sClient.Get(context.TODO(), client.ObjectKeyFromObject(secret), secret)).To(Succeed())

			previousCipherText := secret.Status.Fields["some-field"]
			Expect(previousCipherText).NotTo(BeEmpty())

			secret.Spec.Engine = engineB.Name
			Expect(Test.K8sClient.Update(context.TODO(), secret)).To(Succeed())

			Test.VaultEnv.KvSecret(engineB, secret).Should(HavePath(secret.Name))
			Test.VaultEnv.KvSecret(engineB, secret).Should(HaveKvSecretFieldFieldWithLength("some-field", 64))
			Test.VaultEnv.KvSecret(engineA, secret).Should(BeNil())
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))

			Expect(Test.K8sClient.Get(context.TODO(), client.ObjectKeyFromObject(secret), secret)).To(Succeed())
			Expect(secret.Status.Fields["some-field"]).To(Equal(previousCipherText))
			Test.VaultEnv.KvSecret(engineB, secret).Should(HaveKvSecretFieldFieldWithLength("some-field", 64))
			Test.VaultEnv.KvSecret(engineB, secret).Should(HaveKvSecretFieldWithValue("some-field", oldSecret.Fields["some-field"]))
		})
	})

	When("Changing the path of an auto generated secret", func() {
		var engine *heistv1alpha1.VaultKVSecretEngine
		var secret *heistv1alpha1.VaultKVSecret

		BeforeEach(func() {
			engine = &heistv1alpha1.VaultKVSecretEngine{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecretEngine",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "first-engine",
					Namespace: "default",
				},
				Spec:   heistv1alpha1.VaultKVSecretEngineSpec{},
				Status: heistv1alpha1.VaultKVSecretEngineStatus{},
			}

			secret = &heistv1alpha1.VaultKVSecret{
				TypeMeta: metav1.TypeMeta{
					Kind:       "VaultKVSecret",
					APIVersion: "heist.youniqx.com/v1alpha1",
				},
				ObjectMeta: metav1.ObjectMeta{
					Name:      "some-secret",
					Namespace: "default",
				},
				Spec: heistv1alpha1.VaultKVSecretSpec{
					Engine: engine.Name,
					Fields: map[string]*heistv1alpha1.VaultKVSecretField{
						"some-field": {
							AutoGenerated: true,
						},
					},
					DeleteProtection: false,
				},
				Status: heistv1alpha1.VaultKVSecretStatus{},
			}

			Test.K8sEnv.Create(engine)
			Test.K8sEnv.Create(secret)
			Test.K8sEnv.Object(engine).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Engine has been provisioned",
			))
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))
			Test.VaultEnv.KvSecret(engine, secret).Should(HavePath(secret.Name))
			Test.VaultEnv.KvSecret(engine, secret).Should(HaveKvSecretFieldFieldWithLength("some-field", 64))
			Test.VaultEnv.KvSecret(engine, secret).Should(BeStableFor(4.0 * time.Second))
		})

		AfterEach(func() {
			afterEachCleanup(engine, secret)
		})

		It("Should delete the secret in the previous location and create it in the new one but keep the same values", func() {
			oldSecret, err := Test.RootAPI.ReadKvSecret(engine, secret)
			Expect(err).NotTo(HaveOccurred())
			Expect(oldSecret.Fields["some-field"]).To(HaveLen(64))

			Expect(Test.K8sClient.Get(context.TODO(), client.ObjectKeyFromObject(secret), secret)).To(Succeed())

			previousCipherText := secret.Status.Fields["some-field"]
			Expect(previousCipherText).NotTo(BeEmpty())

			secret.Spec.Path = "some/other/path"
			Expect(Test.K8sClient.Update(context.TODO(), secret)).To(Succeed())

			Test.VaultEnv.KvSecret(engine, secret).Should(HavePath(filepath.Join("some/other/path", secret.Name)))
			Test.VaultEnv.KvSecret(engine, secret).Should(HaveKvSecretFieldFieldWithLength("some-field", 64))
			Test.VaultEnv.KvSecret(engine, core.SecretPath(secret.Name)).Should(BeNil())
			Test.K8sEnv.Object(secret).Should(HaveCondition(
				heistv1alpha1.Conditions.Types.Provisioned,
				metav1.ConditionTrue,
				heistv1alpha1.Conditions.Reasons.Provisioned,
				"Secret has been provisioned",
			))

			Expect(Test.K8sClient.Get(context.TODO(), client.ObjectKeyFromObject(secret), secret)).To(Succeed())
			Expect(secret.Status.Fields["some-field"]).To(Equal(previousCipherText))
			Test.VaultEnv.KvSecret(engine, secret).Should(HaveKvSecretFieldFieldWithLength("some-field", 64))
			Test.VaultEnv.KvSecret(engine, secret).Should(HaveKvSecretFieldWithValue("some-field", oldSecret.Fields["some-field"]))
		})
	})
})

func afterEachCleanup(engine *heistv1alpha1.VaultKVSecretEngine, secret *heistv1alpha1.VaultKVSecret) {
	for i := 0; i < 3; i++ {
		fmt.Printf(":::: test debug output cleanup :::: trying to delete secret engine (try %d/3)\n", i+1)
		Test.K8sEnv.DeleteIfPresent(engine, secret)

		vault, _ := Test.VaultEnv.GetAPI()
		vaultEngineExists, err := vault.HasEngine(engine)
		if err != nil {
			fmt.Printf(":::: test debug output cleanup :::: couldn't check if vault still has engine: %v\n", err)
		}

		fmt.Printf(":::: test debug output cleanup :::: vault engine still exists?: %t\n", vaultEngineExists)
		time.Sleep(1 * time.Second)
	}

	Test.VaultEnv.KvSecret(engine, secret).Should(BeNil())
	Test.VaultEnv.KvEngine(engine).Should(BeNil())
}
